# DSA Problem Solving Workflow:

Step 1ï¸. Understand the Problem
--> Understand the problem by reading the problem statement and also analyzing what is the input format? what is output format? and what are the constraints?
Step 2ï¸. Think of Naive (Brute Force) Solution
--> Ask: If constraints were small, how would I solve it? Brute force is your baseline.
Step 3ï¸. Optimize Step by Step
--> Use patterns like,
Sorting + Two pointers (2-sum, 3-sum, subarray problems).
Hashing (count frequencies, store visited).
Prefix/Suffix (subarray sums, Kadane, rain water).
Stack/Queue (next greater, sliding window).
Recursion/DP (overlapping subproblems).
Step 4ï¸. Dry Run with Small Test Cases
-->  Take tiny inputs (n=3, n=5). Manually simulate your logic.
Example: Array = [16, 17, 4, 3, 5, 2]  From right: 2 âœ… leader, 5 âœ… leader, 17 âœ… leader, 16 âŒ not leader.
--> It helps catch mistakes early.
Step 5ï¸. Code the Solution
--> Write clean code, Use functions and add comments for steps. Start with brute force if stuck, then optimize.
Step 6ï¸. Test with Given + Edge Cases
--> Edge cases: 
Empty array
Single element
All same values
Increasing/decreasing order
Step 7ï¸. Analyze Complexity
Step 8ï¸. Reflect & Generalize
ğŸ‘‰ Example: Leaders in array = similar to Next Greater Element.


# DSA array Problem Solving Workflow:

Step 1. Understand the Problem (U)
--> What should be input, output and restate problem in your own words.
Step 2. Check Constraints (C)
--> Check that What is the size of n?
n â‰¤ 10Â³ â†’ O(nÂ²) acceptable
n â‰¤ 10âµ â†’ O(n log n) or O(n)
n â‰¤ 10â· â†’ Only O(n)
Step 3. Brute Force First (B)
--> Imagine the most direct solution even if slow, it builds understanding.
Step 4. Optimize with Patterns (O)
--> Optimize with patterns by asking the following questions like, 
Can I avoid repeated work?
Useful techniques for arrays:
Prefix / Suffix arrays              
Two Pointers        
Sliding Window
Sorting + Binary Search
Hashing (Map/Set)
Stack/Queue/Heap
Dynamic Programming
Step 5. Dry Run (D)
--> Take a small input.
Walk through your logic step by step.
Track variables on paper.
Step 6. Complexity Analysis (C)
--> Time: How many loops/operations?
Space: Any extra arrays, sets, stacks used?
Step 7. Edge Cases (E)
-->  Always check:
Empty array â†’ []
Single element â†’ [x]
All elements same â†’ [5,5,5]
Sorted increasing â†’ [1,2,3,4]
Sorted decreasing â†’ [9,8,7,6]

## ğŸš€Formula to Remember:-
ğŸ‘‰ U-C-B-O-D-C-E
Understand
Constraints
Brute force
Optimize
Dry run
Complexity
Edge cases
âœ… With this checklist, youâ€™ll have a structured way to solve any array problem.


# DSA Stack Problem Solving Workflow:

Step 1. Understand the Problem (U)
--> First of all we all need to understand the problem which shows what the problem is about:
Matching pairs? (Balanced parentheses, valid expression)
Next element? (Next Greater/Smaller Element, Stock Span)
Span/Range? (Histogram area, Sliding window min/max)
Function calls? (Recursion simulation, Undo/Redo)
Custom stack? (Min Stack, Two Stacks in one array)
Step 2. Check Constraints (C)
--> In this step we all need to check Constraints which means what is the constraint about which includes,
Input size n â†’
If n is large (10âµ or more), O(n log n) / O(n) solution needed.
Value ranges (negative allowed? duplicates?).
Step 3. Brute Force Approach (B)
--> In this step what are the brute force approach which we used for solving stack problem
Use nested loops to simulate the operation.
Check time complexity â†’ usually O(nÂ²).
Step 4. Optimize with Stack Patterns (O)
--> This step shows that how Optimize with Stack patterns.
--> Common Stack Patterns are as follows:
Monotonic Stack
Next Greater Element
Next Smaller Element
Largest Rectangle in Histogram
Balanced Parentheses
Push opening, pop on closing.
Stack empty = valid.
Stock Span Problem
Use stack to store previous higher prices.
Min/Max Stack
Maintain auxiliary stack for min/max.
Expression Problems
Infix â†’ Postfix (Shunting Yard)
Evaluate Postfix/Prefix
Special Structures
Stack using Queue
Queue using Stack
Step 5. Dry Run (D)
--> This step shows that before coding we need to do dry run by-
Always test with small input:
Parentheses: "(()[])â€
NGE: [4, 5, 2, 25]
Histogram: [2, 1, 5, 6, 2, 3]
Step 6. Complexity Check (C)
--> This steps checks Complexity of any code. Complexity of any code can be checked by-
Most optimized stack problems â†’ O(n)
Auxiliary space â†’ O(n)
Step 7. Edge Cases (E)
--> This steps checks Edge Cases which includes-
Empty input â†’ []
Single element stack â†’ [x]
All elements same â†’ [5,5,5]
Increasing / decreasing order arrays
Invalid expressions â†’ "(()" or "([)]"
ğŸš€ Formula for Stack Problems
ğŸ‘‰ U-C-B-O-D-C-E (same universal steps, but optimized for stack)
And always ask:
â€œCan I solve this by maintaining a monotonic stack?â€
â€œDo I need to track indices instead of values?â€
â€œIs it a parentheses matching / expression evaluation problem?â€
âš¡ With this checklist, youâ€™ll have a ready reference for stack problems.



# DSA Queue Problem Solving Workflow

Step 1. Understand the Problem (U)
--> Ask yourself:
Is it about FIFO order (first in, first out)
Do I need a basic queue, circular queue, deque (double-ended queue), or priority queue (heap)?
--> Is the problem related to:
Simulation? (process scheduling, ticketing, task execution)
Traversal? (BFS in graphs/trees)
          Sliding Window? (max/min in subarrays)
                  Custom design? (Queue using Stacks, Stack using Queues)
Step 2. Check Constraints (C)
--> In this step checks for constraints like,
                    Input size (n).  For n â‰¤ 10âµ, use O(n) or O(n log n).
                    For huge inputs, use deque/heap for efficiency.
Step 3. Brute Force (B)
--> In this step check for which brute force to be followed like, 
                         Use array/list and simulate enqueue/dequeue with shifting.
                         Time complexity often becomes O(nÂ²) â†’ too slow.
Step 4. Optimize with Queue Patterns (O)
--> In this steps we will optimize with patterns like,
                       Simple Queue (FIFO)
                       Enqueue at rear, Dequeue at front.
                       Use linked list or collections.deque (Python) / LinkedList (Java).
                       Circular Queue
                       Handles queue overflow in fixed-size arrays.
                       Double-Ended Queue (Deque)
                       Sliding Window Maximum / Minimum.
                       Palindrome check.
                       Priority Queue (Heap)
                       Dijkstraâ€™s Algorithm.
                       Huffman Coding.
                       Kth Largest / Smallest element.
                       Queue-based Traversals
                       BFS in Graphs & Trees.
                       Level Order Traversal.
                       Design Problems
                       Queue using Stacks.
                      Stack using Queues.
Step 5. Dry Run (D)
-->  Try small examples:
                        Queue basics: enqueue(1), enqueue(2), dequeue() â†’ [2]
                        BFS: Graph edges 1-2, 1-3 â†’ Order: [1,2,3]
                        Sliding Window: [1,3,-1,-3,5,3,6,7], k=3 â†’ [3,3,5,5,6,7]
Step 6. Complexity Check (C)
-->  In this step we need to check complexities of a code like, 
                          Enqueue/Dequeue â†’ O(1) in array-based circular queue, linked list, deque.
                          Priority Queue operations â†’ O(log n).
                          BFS â†’ O(V + E).
                          Sliding Window with deque â†’ O(n).
Step 7. Edge Cases (E)
--> In this step we need to check Edge Cases like,
                     Empty queue â†’ dequeue should fail safely.
                     Full queue in circular array.
                     Single element.
                     Repeated elements.
                     Disconnected graph (for BFS).

ğŸš€ Formula for Queue Problems
ğŸ‘‰ U-C-B-O-D-C-E
                          Understand problem type (FIFO, BFS, sliding window, heap).
                          Constraints.
                          Brute force (simulate with list/array).
                          Optimize (deque, heap, linked list).
                          Dry run small input.
                          Complexity check.
                          Edge cases.

ğŸš€ Formula for Queue Problems
ğŸ‘‰ U-C-B-O-D-C-E (same universal steps, but optimized for Queue)
And always ask:
                   â€œCan I solve this by maintaining a monotonic stack?â€
                   â€œDo I need to track indices instead of values?â€
                   â€œIs it a parentheses matching / expression evaluation problem?â€

âš¡ With this checklist, youâ€™ll have a ready reference for Queue problems.

# DSA Linkedlist Problem Solving Workflow


ğŸš€ Formula for Linkedlist Problems
ğŸ‘‰ U-C-B-O-D-C-E (same universal steps, but optimized for Linkedlist)
And always ask:
â€œCan I solve this by maintaining a monotonic stack?â€
â€œDo I need to track indices instead of values?â€
â€œIs it a parentheses matching / expression evaluation problem?â€
âš¡ With this checklist, youâ€™ll have a ready reference for Linkedlist problems.

# DSA Trees Problem Solving Workflow


ğŸš€ Formula for Trees Problems
ğŸ‘‰ U-C-B-O-D-C-E (same universal steps, but optimized for Trees)
And always ask:
â€œCan I solve this by maintaining a monotonic stack?â€
â€œDo I need to track indices instead of values?â€
â€œIs it a parentheses matching / expression evaluation problem?â€
âš¡ With this checklist, youâ€™ll have a ready reference for Trees problems.

# DSA Graph Problem Solving Workflow


ğŸš€ Formula for Graph Problems
ğŸ‘‰ U-C-B-O-D-C-E (same universal steps, but optimized for Graph)
And always ask:
â€œCan I solve this by maintaining a monotonic stack?â€
â€œDo I need to track indices instead of values?â€
â€œIs it a parentheses matching / expression evaluation problem?â€
âš¡ With this checklist, youâ€™ll have a ready reference for Graph problems.
