# DSA Problem Solving Workflow:
Step 1️. Understand the Problem
--> Understand the problem by reading the problem statement and also analyzing what is the input format? what is output format? and what are the constraints?
Step 2️. Think of Naive (Brute Force) Solution
--> Ask: If constraints were small, how would I solve it? Brute force is your baseline.
Step 3️. Optimize Step by Step
--> Use patterns like,
Sorting + Two pointers (2-sum, 3-sum, subarray problems).
Hashing (count frequencies, store visited).
Prefix/Suffix (subarray sums, Kadane, rain water).
Stack/Queue (next greater, sliding window).
Recursion/DP (overlapping subproblems).
Step 4️. Dry Run with Small Test Cases
-->  Take tiny inputs (n=3, n=5). Manually simulate your logic.
Example: Array = [16, 17, 4, 3, 5, 2]  From right: 2 ✅ leader, 5 ✅ leader, 17 ✅ leader, 16 ❌ not leader.
--> It helps catch mistakes early.
Step 5️. Code the Solution
--> Write clean code, Use functions and add comments for steps. Start with brute force if stuck, then optimize.
Step 6️. Test with Given + Edge Cases
--> Edge cases: 
Empty array
Single element
All same values
Increasing/decreasing order
Step 7️. Analyze Complexity
Step 8️. Reflect & Generalize
👉 Example: Leaders in array = similar to Next Greater Element.



# DSA array Problem Solving Workflow:
Step 1. Understand the Problem (U)
--> What should be input, output and restate problem in your own words.
Step 2. Check Constraints (C)
--> Check that What is the size of n?
n ≤ 10³ → O(n²) acceptable
n ≤ 10⁵ → O(n log n) or O(n)
n ≤ 10⁷ → Only O(n)
Step 3. Brute Force First (B)
--> Imagine the most direct solution even if slow, it builds understanding.
Step 4. Optimize with Patterns (O)
--> Optimize with patterns by asking the following questions like, 
Can I avoid repeated work?
Useful techniques for arrays:
Prefix / Suffix arrays              
Two Pointers        
Sliding Window
Sorting + Binary Search
Hashing (Map/Set)
Stack/Queue/Heap
Dynamic Programming
Step 5. Dry Run (D)
--> Take a small input.
Walk through your logic step by step.
Track variables on paper.
Step 6. Complexity Analysis (C)
--> Time: How many loops/operations?
Space: Any extra arrays, sets, stacks used?
Step 7. Edge Cases (E)
-->  Always check:
Empty array → []
Single element → [x]
All elements same → [5,5,5]
Sorted increasing → [1,2,3,4]
Sorted decreasing → [9,8,7,6]
## 🚀Formula to Remember:-
👉 U-C-B-O-D-C-E
Understand
Constraints
Brute force
Optimize
Dry run
Complexity
Edge cases
✅ With this checklist, you’ll have a structured way to solve any array problem.



# DSA Stack Problem Solving Workflow:
Step 1. Understand the Problem (U)
--> First of all we all need to understand the problem which shows what the problem is about:
Matching pairs? (Balanced parentheses, valid expression)
Next element? (Next Greater/Smaller Element, Stock Span)
Span/Range? (Histogram area, Sliding window min/max)
Function calls? (Recursion simulation, Undo/Redo)
Custom stack? (Min Stack, Two Stacks in one array)
Step 2. Check Constraints (C)
--> In this step we all need to check Constraints which means what is the constraint about which includes,
Input size n →
If n is large (10⁵ or more), O(n log n) / O(n) solution needed.
Value ranges (negative allowed? duplicates?).
Step 3. Brute Force Approach (B)
--> In this step what are the brute force approach which we used for solving stack problem
Use nested loops to simulate the operation.
Check time complexity → usually O(n²).
Step 4. Optimize with Stack Patterns (O)
--> This step shows that how Optimize with Stack patterns.
--> Common Stack Patterns are as follows:
Monotonic Stack
Next Greater Element
Next Smaller Element
Largest Rectangle in Histogram
Balanced Parentheses
Push opening, pop on closing.
Stack empty = valid.
Stock Span Problem
Use stack to store previous higher prices.
Min/Max Stack
Maintain auxiliary stack for min/max.
Expression Problems
Infix → Postfix (Shunting Yard)
Evaluate Postfix/Prefix
Special Structures
Stack using Queue
Queue using Stack
Step 5. Dry Run (D)
--> This step shows that before coding we need to do dry run by-
Always test with small input:
Parentheses: "(()[])”
NGE: [4, 5, 2, 25]
Histogram: [2, 1, 5, 6, 2, 3]
Step 6. Complexity Check (C)
--> This steps checks Complexity of any code. Complexity of any code can be checked by-
Most optimized stack problems → O(n)
Auxiliary space → O(n)
Step 7. Edge Cases (E)
--> This steps checks Edge Cases which includes-
Empty input → []
Single element stack → [x]
All elements same → [5,5,5]
Increasing / decreasing order arrays
Invalid expressions → "(()" or "([)]"
🚀 Formula for Stack Problems
👉 U-C-B-O-D-C-E (same universal steps, but optimized for stack)
And always ask:
“Can I solve this by maintaining a monotonic stack?”
“Do I need to track indices instead of values?”
“Is it a parentheses matching / expression evaluation problem?”
⚡ With this checklist, you’ll have a ready reference for stack problems.



# DSA Queue Problem Solving Workflow
Step 1. Understand the Problem (U)
--> Ask yourself:
Is it about FIFO order (first in, first out)
Do I need a basic queue, circular queue, deque (double-ended queue), or priority queue (heap)?
--> Is the problem related to:
Simulation? (process scheduling, ticketing, task execution)
Traversal? (BFS in graphs/trees)
          Sliding Window? (max/min in subarrays)
                  Custom design? (Queue using Stacks, Stack using Queues)
Step 2. Check Constraints (C)
--> In this step checks for constraints like,
                    Input size (n).  For n ≤ 10⁵, use O(n) or O(n log n).
                    For huge inputs, use deque/heap for efficiency.
Step 3. Brute Force (B)
--> In this step check for which brute force to be followed like, 
                         Use array/list and simulate enqueue/dequeue with shifting.
                         Time complexity often becomes O(n²) → too slow.
Step 4. Optimize with Queue Patterns (O)
--> In this steps we will optimize with patterns like,
                       Simple Queue (FIFO)
                       Enqueue at rear, Dequeue at front.
                       Use linked list or collections.deque (Python) / LinkedList (Java).
                       Circular Queue
                       Handles queue overflow in fixed-size arrays.
                       Double-Ended Queue (Deque)
                       Sliding Window Maximum / Minimum.
                       Palindrome check.
                       Priority Queue (Heap)
                       Dijkstra’s Algorithm.
                       Huffman Coding.
                       Kth Largest / Smallest element.
                       Queue-based Traversals
                       BFS in Graphs & Trees.
                       Level Order Traversal.
                       Design Problems
                       Queue using Stacks.
                      Stack using Queues.
Step 5. Dry Run (D)
-->  Try small examples:
                        Queue basics: enqueue(1), enqueue(2), dequeue() → [2]
                        BFS: Graph edges 1-2, 1-3 → Order: [1,2,3]
                        Sliding Window: [1,3,-1,-3,5,3,6,7], k=3 → [3,3,5,5,6,7]
Step 6. Complexity Check (C)
-->  In this step we need to check complexities of a code like, 
                          Enqueue/Dequeue → O(1) in array-based circular queue, linked list, deque.
                          Priority Queue operations → O(log n).
                          BFS → O(V + E).
                          Sliding Window with deque → O(n).
Step 7. Edge Cases (E)
--> In this step we need to check Edge Cases like,
                     Empty queue → dequeue should fail safely.
                     Full queue in circular array.
                     Single element.
                     Repeated elements.
                     Disconnected graph (for BFS).
🚀 Formula for Queue Problems
👉 U-C-B-O-D-C-E
                          Understand problem type (FIFO, BFS, sliding window, heap).
                          Constraints.
                          Brute force (simulate with list/array).
                          Optimize (deque, heap, linked list).
                          Dry run small input.
                          Complexity check.
                          Edge cases.
🚀 Formula for Queue Problems
👉 U-C-B-O-D-C-E (same universal steps, but optimized for Queue)
And always ask:
                   “Can I solve this by maintaining a monotonic stack?”
                   “Do I need to track indices instead of values?”
                   “Is it a parentheses matching / expression evaluation problem?”
⚡ With this checklist, you’ll have a ready reference for Queue problems.



# DSA Linkedlist Problem Solving Workflow
Step 1. Understand the Problem (U)
--> First step is to answer two questions like,  What kind of linked list used?
          Singly Linked List
          Doubly Linked List
          Circular Linked List
and What operation is asked?
               Traversal / Searching
               Insertion / Deletion
               Reversal
               Cycle detection
               Merging / Sorting
               Middle / Nth node operations
Step 2. Check Constraints (C)
--> Second step is to check for constraints like,
Size of the linked list (n).
Large n (up to 10⁵ or more) → O(n) or O(n log n) needed.
Extra space usage allowed? (sometimes only O(1) is expected).
Step 3. Brute Force (B)
--> Third step is to analyse brute force
             Convert linked list → array.
             Solve problem using array operations.
             Convert back to linked list if needed.
             Usually O(n) time but O(n) extra space.
Step 4. Optimize with Linked List Patterns (O)
--> Fourth step is to optimize with patterns which means what kind of patterns it follows.
⚡ Common Linked List Patterns are:
              Two Pointers (Fast & Slow)
              Find middle node.
              Detect cycle (Floyd’s algorithm).
              Find Nth node from end.
              Reversal
              Iterative with 3 pointers (prev, curr, next).
              Recursive method.
              Merge / Sort
              Merge two sorted lists → O(n).
              Merge sort for linked list → O(n log n).
              Cycle Problems
              Detect cycle → Floyd’s algorithm.
              Remove cycle → detect meeting point, reset pointer.
              Dummy Node Technique
              Used for simplifying insertion/deletion logic.
              Doubly Linked List
              Forward & backward traversal.
              Delete node in O(1) if pointer given.
Step 5. Dry Run (D)
--> Fifth step is to do dry run  
Test with small cases:
1 → 2 → 3 → 4
Insert at head → 0 → 1 → 2 → 3 → 4
Reverse → 4 → 3 → 2 → 1
Detect cycle → 1 → 2 → 3 → 4 → 2
Step 6. Complexity Check (C)
--> Sixth step is to check complexity,
Traversal → O(n).
Insertion/Deletion at head/tail → O(1).
Searching → O(n).
Merge sort → O(n log n).
Cycle detection → O(n), O(1) space.
Step 7. Edge Cases (E)
--> Seventh step is to do Edge cases
Empty list (head = null).
Single node.
Even vs odd length (middle element).
Self-loop (node pointing to itself).
Multiple cycles in test cases.
🚀 Formula for Linked List Problems
👉 U-C-B-O-D-C-E
Understand the type (singly, doubly, circular).
Check constraints.
Brute force with arrays.
Optimize (two pointers, dummy node, reversal, merge).
Dry run small examples.
Complexity analysis.
Edge cases.
⚡ With this checklist, you’ll have a ready reference for Linkedlist problems.



# DSA Trees Problem Solving Workflow
Step 1. Understand the Problem (U)
--> First step is to answer two questions like, What type of tree?
             Binary Tree
             Binary Search Tree (BST)
             N-ary Tree
             Special Tree (Trie, Segment Tree, AVL, Heap)
What is asked?
            Traversal (inorder, preorder, postorder, level order)
            Search, Insert, Delete
            Height, Diameter, Lowest Common Ancestor (LCA)
            Path problems (max path sum, root-to-leaf paths)
            Conversions (BST → DLL, flatten tree, serialize/deserialize)
Step 2. Check Constraints (C)
--> Second step is to check for constraints like,
               Number of nodes (n).
               Small n → recursion okay.
               Large n (10⁵) → avoid deep recursion → iterative / BFS.
               Node values (negative allowed? unique or not?).
Step 3. Brute Force (B)
--> Third step is to analyse brute force
           Use recursion for traversals.
           For queries (like height, diameter, etc.) → recompute multiple times (O(n²) sometimes).
Step 4. Optimize with Tree Patterns (O)
--> Fourth step is to optimize with patterns which means what kind of patterns it follows.
⚡ Common Tree Patterns:
         DFS Traversals
         Inorder (LNR) → BST sorted order.
         Preorder (NLR) → root-first problems.
         Postorder (LRN) → bottom-up problems.
         BFS Traversal (Queue)
         Level Order
         Zigzag / Spiral traversal
         Connect nodes at same level
         Divide & Conquer / Recursion
         Height, Diameter, Balanced Tree → use postorder.
         LCA → recursive DFS.
         BST Properties
         Left < Root < Right.
         Inorder traversal is sorted.
         Search/Insert/Delete → O(h), h = height.
--> Advanced Trees
        Trie → Prefix problems.
        Segment Tree → Range queries.
        Heap (Priority Queue) → Max/Min element efficiently.
Step 5. Dry Run (D)
--> Fifth step is to do dry run
Example Tree:
       1
     /   \
    2     3
   / \   / \
  4   5 6   7
Inorder: 4,2,5,1,6,3,7
Preorder: 1,2,4,5,3,6,7
Postorder: 4,5,2,6,7,3,1
Level order: 1,2,3,4,5,6,7
Step 6. Complexity Check (C)
--> Sixth step is to check complexity
          Traversals → O(n).
          Search in BST → O(h).
          Balanced BST → O(log n) per operation.
          Height/Diameter → O(n).
          LCA → O(h).
Step 7. Edge Cases (E)
--> Seventh step is to do Edge cases
Empty tree (root = null).
Single node.
Skewed tree (all left / all right).
Duplicate values.
Unbalanced trees.
🚀 Formula for Tree Problems
👉 U-C-B-O-D-C-E
Understand type of tree (BT, BST, Trie, Heap).
Check constraints.
Brute force with recursion.
Optimize (DFS, BFS, divide & conquer, BST properties).
Dry run on small tree.
Complexity check.
Edge cases (empty, skewed, duplicates).
⚡ With this checklist, you’ll have a ready reference for Trees problems.



# DSA Graph Problem Solving Workflow
Step 1. Understand the Problem (U)
--> First step is to answer two questions like, What kind of graph?
            Directed / Undirected
            Weighted / Unweighted
            Cyclic / Acyclic
                 Representation:
                      Adjacency List (sparse graphs)
                      Adjacency Matrix (dense graphs)
What is asked?
            Traversal (BFS, DFS)
            Shortest Path
            Connected Components
            Cycle detection
            Topological Sort like MST (Minimum Spanning Tree)
Step 2. Check Constraints (C)
--> Second step is to check for constraints like,
           Number of nodes (V) and edges (E).
                  If V, E ≤ 10³ → adjacency matrix OK.
                  If V, E ≤ 10⁵ → adjacency list + BFS/DFS/Dijkstra.
           Graph connected? Directed? Multiple edges? Negative weights?
Step 3. Brute Force (B)
--> Third step is to analyse brute force
                Try all paths / check every edge repeatedly.
                Exponential in some cases (not feasible).
                Helps understand structure but not efficient.
Step 4. Optimize with Graph Patterns (O)
-->Fourth step is to optimize with patterns  which means which types of patterns it follows, 
⚡ Common Graph Patterns:
             Traversal
                     BFS (queue) → shortest path in unweighted graphs.
                     DFS (stack/recursion) → explore components, cycle detection.
             Cycle Detection
                         Undirected: DFS with parent tracking.
                         Directed: DFS with recursion stack OR Kahn’s Algorithm (topological sort).
             Shortest Path
                     Unweighted → BFS.
                     Weighted → Dijkstra’s (non-negative weights).
                     Negative weights → Bellman-Ford.
                     All pairs → Floyd-Warshall.
                                    Minimum Spanning Tree (MST)
                                    Kruskal’s (Union-Find).
                                    Prim’s (Priority Queue).
             Topological Sorting (DAG)
                                DFS + Stack.
                                BFS (Kahn’s Algorithm).
             Special Graphs
                            Bipartite → BFS coloring.
                            Disjoint Sets → Union-Find (Kruskal’s, cycle detection).
                            Grid Graphs → BFS/DFS for islands, shortest path in matrices.
Step 5. Dry Run (D)
--> Fifth step is to do dry run
Graph Example (Adjacency List):
1 -- 2
|    |
4 -- 3
BFS from 1 → 1,2,4,3
DFS from 1 → 1,2,3,4
Step 6. Complexity Check (C)
--> Sixth step is to check complexity
                   BFS/DFS → O(V + E).
                   Dijkstra → O((V+E) log V).
                   Bellman-Ford → O(V*E).
                   Floyd-Warshall → O(V³).
                   Kruskal’s / Prim’s → O(E log V).
Step 7. Edge Cases (E)
--> Seventh step is to do Edge cases
                    Empty graph.
                    Disconnected graph.
                    Single node.
                    Self-loops / multiple edges.
                    Negative weights.
                    Directed vs undirected differences.
🚀 Formula for Graph Problems
👉 U-C-B-O-D-C-E
Understand type (directed, weighted, cyclic).
Check constraints (V, E).
Brute force (all paths).
Optimize (BFS, DFS, Dijkstra, Union-Find, Topo sort).
Dry run small graph.
Complexity check.
Edge cases.
⚡ With this checklist, you’ll have a ready reference for Graph problems.


📑 DSA Master Roadmap (One-Page Checklist)
🔹 Universal Formula → U-C-B-O-D-C-E
U → Understand the problem (type & requirements)
C → Check constraints (n, values, memory)
B → Brute force first
O → Optimize with known patterns
D → Dry run with small input
C → Complexity analysis
E → Edge cases


✨ Conclusion
--> Solving DSA problems becomes much easier when you follow a structured approach. 
--> The universal formula U-C-B-O-D-C-E (Understand → Constraints → Brute Force → Optimize → Dry Run → Complexity → Edge Cases) helps you stay systematic and confident, no matter the topic (Arrays, Stacks, Queues, Linked Lists, Trees, Graphs).

Key mindset:
--> First understand the problem (don’t rush into coding).
--> Always think of the brute force approach as a baseline.
--> Identify patterns and optimize step by step.
--> Never skip edge cases and complexity analysis.

🚀 Next Step
--> Practice new problems using this checklist.
--> Always do small dry runs before coding.
--> Keep track of mistakes and reflections → that’s how you build intuition.

🤝 Contribution / Feedback
If you found these notes useful, don’t forget to ⭐ star this repo.
Feel free to suggest improvements or share feedback via Pull Requests.

🔥 DSA is not about memorizing solutions, it’s about building patterns in your mind.
